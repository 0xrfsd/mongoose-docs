# mongoose-docs

Mongoose 

Terminologies:

Collections = ‘Collections’ in Mongo are equivalent to tables in relational databases. They can hold multiple JSON documents.

Documents = ‘Documents’ are equivalent to records or rows of data in SQL. While a SQL row can reference data in other tables, Mongo documents usually combine that in a document
 
Fields = ‘Fields’ or attributes are similar to columns in a SQL table

Schema = ’Schema’ While Mongo is schema-less, SQL defines a schema via the table definition. A Mongoose ’schema’ is a document data structure (or shape of the document) that is enforcced via the application layer

Models = ‘Models’ are high-order constructors that take a schema and create an instance of a doument equivalent to records in a relational database


Getting Started


NPM Install

To initialize our project we type
$ npm init -y

To install mongoose and validation we type
$ npm install mongoose validator



Database Connection

let mongoose = require(“mongoose”);

const server = ‘127.0.0.0.1:27017’;  // REPLACE WITH YOUR DB SERVER
const database = ‘dcc-Mail’           // REPLACE WITH YOUR DB NAME

class Database {
  constructor() {
    this._connect()
  }

  _connect() {
    mongoose.connect(`mongodb://${server}/${database}`)
      .then(() => {
        console.log(‘Database connection succesful’)
      })
  }
}

module.exports = new Database ()



Mongoose Schema vs. Model

A Mongoose model is a wrappepr on the Mongoose schema. 

A Mongoose schema defines the structure of the document, default values, validators, etc… 
 
A Mongoose Model provides an interface to the database for creating, querying, updating, deleting records, etc.

Referecing Mongoose

Let mongoose = require(‘mongoose’)

Defining the Schema

Let emailSchema = new mongoose.Schema({
  email: String
})

Here we define a property called email with a schema type String which maps to an internal validator that will be trirggered when the moddel is savedto the database. It will fail if hte data type of the value is not aa strirng type.

The followinf Schema Types are permited:

Array
Boolean
Buffer
Date
Mixed (A generic or flexible data type)
Number
ObjectID
String

Mixed and ObjectID are defined under require(‘mongoose’).Schema.Types

Exporting a Model

We need to call the model constructor on the Mongoose instance and pass it the name of the collection and a reference to the schema definition.

Module.exports = mongoose.model(‘Email’, emailSchema)

A schema definitio should be simple, but its complexity is usually based on application requirements. Scehmas can be reused and they can contain several child-schemas too. In the example aboce, the value of the email property is a simple value type. However, it can also be an object type with additional properties on it.

We canc reate an instance of the model we defined aboce and populate it using the following syntax:

let EmailModel = require(‘./email’)

let msg = new EmailModel({
  email: ‘ricardo@gmail.com'
})

Let’s enhance the Email schema to make the email property a unique, required field and convert the value to lowercase before saving it. We can also add a validation function that will ensure that the value is a valid email address. We will reference and use the validator library installed earlier.

let mongoose = require(‘mongoose’)
let validator = require(‘validator’)

let emailSchema = new mongoose.schema({
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    validate: (value) => {
      return validator.isEmail(value)
    }
  }
})

module.exports = mongoose.model(‘Email’, emailSchema)


Basic Operations

Create Record - Let’s create an instance of the email model and save it to the database:

let EmailModel = require(‘./email’)

let msg = new EmailModel({
  email: ‘ricardo@gmail.com'
})

msg.save()
    .then(doc => {
      console.log(doc)
    })
    .catch(err => {
      console.log(err)
    })

The result is a document that is returned upon a successful save:

{
  _id: 5a35ss6373as9a0,
  email: ‘ricardo@gmail.com’,
  __v: 0
}

The following fields are returned (internal fields are prefixed with an underscore)

The _id field is auto-generated by Mongo and is a primary key of the collecetion. Its value is a unique identifier for the document
The value of the email fields is returned. Notice that it is lower-cased because we specified the lowercase:true attribute in the schema
__v is the versionKey property set on each document when first created by Mongoose. Its value contains the internal revision of the document


Fetch Record

Let’s try to retrieve the record we saved to the database earlier. The moddel clas exposes several static and instance methods to perform operations on the database. We will now trry to find the record that we created previously using the find method and pass the email as the search term

EmailModel
    .find({
      email: ‘ricardo@gmail.com’    // search query
    })
    .then(doc => {
      console.log(doc)
    })
    .catch(err => {
      console.error(err)
    })

The document returned will be similar to what was displayed when we create the record:

{
  _id: 5a35ss6373as9a1,
  email: ‘ricardo@gmail.com’,
  __v: 0
}


Update Record

Let’s modify the record above by changing the email address and adding another field to it, all in a single oepration. For performance reasons, mongoose won’t return the updated document so we need to pass an additional parameter to ask for it:

EmailModel
    .findOneAndUpdate(
      {
        email: ‘ricardo@gmail.com’    // search query
      },
      {
        email: ’new@gmail.com’        // field:values to update
      },
      {
        new: true,
        runValidators: true
      })
    .then(doc => {
      console.log(doc)
    })
    .catch(err => {
      console.error(err)
    })
   
The document returned will contain the updated email:

{
  _id: 5a35ss6373as9a1,
  email: ’new@gmail.com’,
  __v: 0
}


Delete Record

We will use the findOneAndRemove call to delete a record. It returns the original document that was removed: 

EmailModel
    .findOneAndRemove({
      email: ’new@gmail.com'
    })
    .then(response => {
      console.log(response)
    })
    .catch(err => {
      console.error(err)
    })


Helpers

We have looked at some of the basic functionality aboce know as CRUD (Create, Read, Update, Delete) operations, but mongoose also provides the ability to configure several types of helper methods and properties. These can be used to further simplify working with data.

Let’s create a user schema with fields firstName and lastName:

let mongoose = require(‘mongoose’)

let userSchema = new mongoose.Schema({
  firstName: String,
  lastName: String
})

module.exports = mongoose.model(‘User’, userSchema)


Virtual Property

A virtual property is not persited to the database. We can add it to our schema as a helper to get and set values.

Let’s create a virtual property called fullName which can be used to set values on firstName and lastName and retrieve them as a combined value when read:

userSchema.virtual(‘fullname’).get(function() {
  return this.firstName + ‘ ’ + this.lastName 
})

userSchema.virtual(‘fullName’).set(function(name) {
  let str = name.split(‘ ‘)

  this.firstName = str[0]
  this.lastName = str[1]
})

Callbacks for get and set must use the function keyword as we need to access the model via the this keyword. Using fat arrow functions will change what this refers to.

Now, we can set firstName and lastName by assigning a value to fullName:

let model = new UserModel()

Model.fullName = ’Thomas Anderson’

console.log(model.toJSON())   // Output model fields as JSON
console.log()
console.log(model.fullName)    // Output the full name

The code aboce will output the following:

{
  _id: 6bd6s523dn37f52cf,
  firstName: ’Thomas’,
  lastName: ‘Anderson'
}

Thomas Anderson


Instance Methods

We can create custom helper methods on the schema and access them via the model instance. These methods will have access to the model object and they can be used quite creativily. For instance, we could create amethod to find all the people who have the same first name as the current instance.

In this example, let’s create a function to return the initials for the current user. Let’s add a custom helper methods called getInitials to the schema:

userSchema.methods.getInitials = function() {
  return this.firstName[0] + this.lastName[0]
}

This method will be accessible via a model instance:

let model = new UserModel({
  firstName: ’Thomas’,
  lastName: ‘Anderson'
})

let initials = model.getInitials()

console.log(initials) // This will output: TA


Static Methods

Similar to instance methods, we can create static methods on the schema. Let’s create a method to retrieve all users in the database:

userSchema.statics.getUsers = function() {
  return new Promise((resolve, reject) => {
    this.fin((err, docs) => {
      If(err) {
        console.error(err)
        return reject(err)
      }

      resolve(docs)
    })
  })
}

Calling getUsers on the Model class will return all the users in the database:

UserModel.getUsers()
    .then(docs => {
      console.log(docs)
    })
    .catch(err => {
      console.error(err)
    })

Adding instance and static methods is a nice approach to implement an interface to database interactions on collecetions and records.


Middleware

Middleware are functions that run at speciic stages of a pipeline. Mongoose supports middleware for the following operations:

Aggregate
Document
Model
Query

For instance, models have pre and post functions that take two parameters:

Type of event (‘init’, ‘validate’, ’save’, ‘remove’)
A callback that is executed with this referencing the model instance

User Modeel => Pre-Save Middleware => [ Generate Password Hash, Save ] => [ Write to Database, Post-Save Middleware ] => Send Email when user account is created

Let’s try an example by aadding two fields called createdAt and updatedAt to our schema:

let mongoose = require(‘mongoose’)

let userSchema = new mongoose.Schema({
  firstName: String,
  lastName: String,
  createdAt: Date,
  updatedAt: Date
})

module.exports = mongoose.model(‘User’, userSchema)

When model.save() is called, there is a pre(‘save’, …) and post(‘save’, …) event that is triggered. For the second parameter, you can pass a function that is called when the event is triggered. For the second parameter, you can pass a function that is called when the event is triggered. These functions take a parameter to the next function in the middleware chain.

Let’s add a pre-save hook and set values for createdAt and updatedAt:

userSchema.pre(’save’, function (next) {
  let now = Date.now()

  this.updatedAt = now

  // Set a value for createdAt only if it is null
  if (!this.createdAt) {
    this.createdAt = now
}

  // Call the next function in the pre-save chain
  next()
})

Let’s create and save our model:

let UserModel = require(‘./user’)

let model = new UserModel({
  fullName: ’Thomas Anderson'
})

msg.save()
    .then(doc => {
      console.log(doc)
    })
    .catch(err => {
       console.error(err)
    })

You shoul see values for createdAt and updatedAt when the receord that is created is printed:

{
  _id: 6bd6s523dn37f52cf,
  firstName: ’Thomas’,
  lastName: ‘Anderson’
  updatedAt: 2020-02-12:03:37:44,
  createdAt: 2020-02-12:03:37:44,
  __v: 0
}


Plugins

Suppose that we want to track when a record was created and last updated on every collection in our database. Instead of repeating the above process, we can create a plugin and appl it to every schema.

Let’s create a file timestamp.js and replicate the aboce functionality as reusable module:

module.exports = function timestamp(schema) {

  // Add the two fields to the schema
  schema.add({
    createdAt: Date,
    updatedAt: Date
  })

  // Create a pre-save hook
  schema.pre(’save’, function (next) {
    let now = Date.now()

    this.updatedAt = now

    // Set a value for createdAt only if it is null
    If (!this.createdAt) {
      this.createdAt = now
    }

    // Call the next function in the pre-save chain
    next()
  })
}

To use the plugin, we simply pass it to the schemas that should be given this functionalityL

let timestampPlugin = require(‘./timestamp’)

emailSchema.plugin(timestampPlugin)
userSchema.plugin(timestampPlugin)


Query Building

Mongoose has a very rich API that handles many complex operations supported by MongoDB. Consider a query where we can incrementally build query components.

In this example, we are going to:

Find all uses
Skip the first 100 records
Limit the results to 10 records
Sort the results by the firstName field
Select the firstName
Execute that query

UserModel.find()
    .skip(100)
    .limit(10)
    .sort({firstName: 1})
    .select({firstName: true})
    .then(docs => {
      console.log(docs)
    })
    .catch(err => {
      console.error(err)
    })


Closing
